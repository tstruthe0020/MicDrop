import Foundation
import AudioToolbox
import AVFoundation
import ArgumentParser

// MARK: - Error Types
struct RuntimeError: Error {
    let message: String
    init(_ message: String) {
        self.message = message
    }
}

extension RuntimeError: LocalizedError {
    var errorDescription: String? { message }
}

// MARK: - Helper Extensions
extension String {
    func fourCharCodeValue() -> UInt32 {
        let chars = Array(utf8)
        guard chars.count == 4 else { return 0 }
        return UInt32(chars[0]) << 24 | UInt32(chars[1]) << 16 | UInt32(chars[2]) << 8 | UInt32(chars[3])
    }
}

extension UInt32 {
    func fourCharString() -> String {
        let chars = [
            Character(UnicodeScalar((self >> 24) & 0xFF)!),
            Character(UnicodeScalar((self >> 16) & 0xFF)!),
            Character(UnicodeScalar((self >> 8) & 0xFF)!),
            Character(UnicodeScalar(self & 0xFF)!)
        ]
        return String(chars)
    }
}

// MARK: - Data Structures
struct ValuesData: Codable {
    let values: [String: Double]
    
    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        self.values = try container.decode([String: Double].self)
    }
    
    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(values)
    }
}

// MARK: - Main CLI Structure
@main
struct AUPresetGen: ParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "aupresetgen",
        abstract: "Generate Audio Unit presets using native macOS Audio Unit APIs",
        subcommands: [SavePreset.self, ListParams.self],
        defaultSubcommand: SavePreset.self
    )
}

// MARK: - Save Preset Command
struct SavePreset: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Save an Audio Unit preset with specified parameters"
    )
    
    @Option(name: .long, help: "Audio Unit type (4-character string)")
    var type: String
    
    @Option(name: .long, help: "Audio Unit subtype (4-character string)")  
    var subtype: String
    
    @Option(name: .long, help: "Audio Unit manufacturer (4-character string)")
    var manufacturer: String
    
    @Option(name: .long, help: "JSON file containing parameter values")
    var values: String
    
    @Option(name: .long, help: "Name for the generated preset")
    var presetName: String
    
    @Option(name: .long, help: "Output directory")
    var outDir: String
    
    @Option(name: .long, help: "Plugin name for ZIP organization")
    var pluginName: String?
    
    @Flag(name: .long, help: "Create ZIP package with Logic Pro folder structure")
    var makeZip: Bool = false
    
    @Option(name: .long, help: "Custom ZIP file path")
    var zipPath: String?
    
    @Option(name: .long, help: "Bundle root directory name for ZIP structure")
    var bundleRoot: String = "Audio Music Apps"
    
    @Flag(name: .long, help: "Enable verbose output")
    var verbose: Bool = false
    
    func run() throws {
        if verbose {
            print("üöÄ Starting AU preset generation...")
            print("üìù Type: \(type), Subtype: \(subtype), Manufacturer: \(manufacturer)")
            print("üìÅ Output: \(outDir)")
            print("üìã Preset: \(presetName)")
        }
        
        // Convert string identifiers to UInt32
        let typeCode = type.fourCharCodeValue()
        let subtypeCode = subtype.fourCharCodeValue()  
        let manufacturerCode = manufacturer.fourCharCodeValue()
        
        if verbose {
            print("üî¢ Codes - Type: \(typeCode), Subtype: \(subtypeCode), Manufacturer: \(manufacturerCode)")
        }
        
        // Load parameter values
        let valuesData = try loadParameterValues(from: values)
        if verbose {
            print("üìä Loaded \(valuesData.values.count) parameter values")
        }
        
        // Create output directory
        let outputURL = URL(fileURLWithPath: outDir)
        try FileManager.default.createDirectory(at: outputURL, withIntermediateDirectories: true)
        
        // Generate the preset
        let presetURL = outputURL.appendingPathComponent("\(presetName).aupreset")
        try generatePreset(
            type: typeCode,
            subtype: subtypeCode,
            manufacturer: manufacturerCode,
            values: valuesData.values,
            outputURL: presetURL
        )
        
        if verbose {
            print("‚úÖ Generated preset: \(presetURL.path)")
        }
        
        // Create ZIP package if requested
        if makeZip {
            try createZipPackage(
                presetURL: presetURL,
                pluginName: pluginName ?? "Unknown",
                outputDir: outDir,
                customZipPath: zipPath,
                bundleRoot: bundleRoot
            )
        }
        
        print("üéâ Preset generation completed successfully!")
    }
    
    private func loadParameterValues(from path: String) throws -> ValuesData {
        let url = URL(fileURLWithPath: path)
        let data = try Data(contentsOf: url)
        return try JSONDecoder().decode(ValuesData.self, from: data)
    }
    
    private func generatePreset(
        type: UInt32,
        subtype: UInt32, 
        manufacturer: UInt32,
        values: [String: Double],
        outputURL: URL
    ) throws {
        if verbose {
            print("üîç Looking for Audio Unit...")
        }
        
        let description = AudioComponentDescription(
            componentType: type,
            componentSubType: subtype,  // Fixed: was componentSubtype, now componentSubType
            componentManufacturer: manufacturer,
            componentFlags: 0,
            componentFlagsMask: 0
        )
        
        // Find the Audio Unit component
        guard let component = AudioComponentFindNext(nil, &description) else {
            throw RuntimeError("Audio Unit not found: \(type.fourCharString())/\(subtype.fourCharString())/\(manufacturer.fourCharString())")
        }
        
        if verbose {
            print("üéõÔ∏è  Found Audio Unit component")
        }
        
        // Instantiate the Audio Unit
        var au: AudioUnit?
        let instantiateStatus = AudioComponentInstanceNew(component, &au)
        guard instantiateStatus == noErr, let audioUnit = au else {
            throw RuntimeError("Failed to instantiate Audio Unit: \(instantiateStatus)")
        }
        
        defer {
            AudioComponentInstanceDispose(audioUnit)
        }
        
        if verbose {
            print("üîß Instantiated Audio Unit")
        }
        
        // Initialize the Audio Unit
        let initStatus = AudioUnitInitialize(audioUnit)
        guard initStatus == noErr else {
            throw RuntimeError("Failed to initialize Audio Unit: \(initStatus)")
        }
        
        defer {
            AudioUnitUninitialize(audioUnit)
        }
        
        if verbose {
            print("‚ö° Initialized Audio Unit")
        }
        
        // Get parameter list
        var paramListSize: UInt32 = 0
        // Fixed: Use UnsafeMutableRawPointer(bitPattern: 0) instead of nil
        let paramListStatus = AudioUnitGetProperty(audioUnit, kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, UnsafeMutableRawPointer(bitPattern: 0), &paramListSize)
        guard paramListStatus == noErr else {
            throw RuntimeError("Failed to get parameter list size: \(paramListStatus)")
        }
        
        let paramCount = Int(paramListSize) / MemoryLayout<AudioUnitParameterID>.size
        if verbose {
            print("üìã Audio Unit has \(paramCount) parameters")
        }
        
        var parameterIDs = [AudioUnitParameterID](repeating: 0, count: paramCount)
        let getParamsStatus = AudioUnitGetProperty(
            audioUnit,
            kAudioUnitProperty_ParameterList,
            kAudioUnitScope_Global,
            0,
            &parameterIDs,
            &paramListSize
        )
        guard getParamsStatus == noErr else {
            throw RuntimeError("Failed to get parameter list: \(getParamsStatus)")
        }
        
        // Apply parameter values
        var appliedCount = 0
        for (key, value) in values {
            if let paramID = AudioUnitParameterID(key) {
                let setStatus = AudioUnitSetParameter(
                    audioUnit,
                    paramID,
                    kAudioUnitScope_Global,
                    0,
                    AudioUnitParameterValue(value),
                    0
                )
                
                if setStatus == noErr {
                    appliedCount += 1
                    if verbose {
                        print("‚úÖ Set parameter \(paramID) = \(value)")
                    }
                } else if verbose {
                    print("‚ö†Ô∏è  Failed to set parameter \(paramID): \(setStatus)")
                }
            } else if verbose {
                print("‚ö†Ô∏è  Invalid parameter ID: \(key)")
            }
        }
        
        if verbose {
            print("üéöÔ∏è  Applied \(appliedCount)/\(values.count) parameters")
        }
        
        // Generate the preset file
        try saveAudioUnitPreset(audioUnit: audioUnit, to: outputURL)
        
        if verbose {
            print("üíæ Saved preset to: \(outputURL.path)")
        }
    }
    
    private func saveAudioUnitPreset(audioUnit: AudioUnit, to url: URL) throws {
        // Export Audio Unit state
        var propertySize: UInt32 = 0
        // Fixed: Use UnsafeMutableRawPointer(bitPattern: 0) instead of nil
        let sizeStatus = AudioUnitGetProperty(audioUnit, kAudioUnitProperty_ClassInfo, kAudioUnitScope_Global, 0, UnsafeMutableRawPointer(bitPattern: 0), &propertySize)
        guard sizeStatus == noErr else {
            throw RuntimeError("Failed to get ClassInfo size: \(sizeStatus)")
        }
        
        // Allocate buffer for the property data
        let buffer = UnsafeMutableRawPointer.allocate(byteCount: Int(propertySize), alignment: 1)
        defer {
            buffer.deallocate()
        }
        
        let getStatus = AudioUnitGetProperty(
            audioUnit,
            kAudioUnitProperty_ClassInfo,
            kAudioUnitScope_Global,
            0,
            buffer,
            &propertySize
        )
        guard getStatus == noErr else {
            throw RuntimeError("Failed to get ClassInfo: \(getStatus)")
        }
        
        // Convert to CFPropertyList
        let data = Data(bytes: buffer, count: Int(propertySize))
        guard let plist = try? PropertyListSerialization.propertyList(from: data, format: nil) else {
            throw RuntimeError("Failed to deserialize ClassInfo")
        }
        
        // Write to file
        let plistData = try PropertyListSerialization.data(fromPropertyList: plist, format: .xml, options: 0)
        try plistData.write(to: url)
        
        if verbose {
            print("üìù Wrote \(plistData.count) bytes to preset file")
        }
    }
    
    private func createZipPackage(
        presetURL: URL,
        pluginName: String,
        outputDir: String,
        customZipPath: String?,
        bundleRoot: String
    ) throws {
        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        // Create Logic Pro folder structure
        let bundleDir = tempDir.appendingPathComponent(bundleRoot)
        let pluginSettingsDir = bundleDir.appendingPathComponent("Plug-In Settings")
        let pluginDir = pluginSettingsDir.appendingPathComponent(pluginName)
        
        try FileManager.default.createDirectory(at: pluginDir, withIntermediateDirectories: true)
        
        // Copy preset file
        let destPresetURL = pluginDir.appendingPathComponent(presetURL.lastPathComponent)
        try FileManager.default.copyItem(at: presetURL, to: destPresetURL)
        
        // Determine ZIP path
        let zipURL: URL
        if let customPath = customZipPath {
            zipURL = URL(fileURLWithPath: customPath)
        } else {
            zipURL = URL(fileURLWithPath: outputDir).appendingPathComponent("\(pluginName).zip")
        }
        
        // Create ZIP using ditto (macOS native)
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/ditto")
        process.arguments = ["-c", "-k", "--keepParent", tempDir.path, zipURL.path]
        
        try process.run()
        process.waitUntilExit()
        
        guard process.terminationStatus == 0 else {
            throw RuntimeError("ditto command failed with status \(process.terminationStatus)")
        }
        
        if verbose {
            print("üì¶ Created ZIP package: \(zipURL.path)")
        }
    }
}

// MARK: - List Parameters Command
struct ListParams: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "List available parameters for an Audio Unit"
    )
    
    @Option(name: .long, help: "Audio Unit type (4-character string)")
    var type: String
    
    @Option(name: .long, help: "Audio Unit subtype (4-character string)")
    var subtype: String
    
    @Option(name: .long, help: "Audio Unit manufacturer (4-character string)")
    var manufacturer: String
    
    @Flag(name: .long, help: "Enable verbose output")
    var verbose: Bool = false
    
    func run() throws {
        let typeCode = type.fourCharCodeValue()
        let subtypeCode = subtype.fourCharCodeValue()
        let manufacturerCode = manufacturer.fourCharCodeValue()
        
        let description = AudioComponentDescription(
            componentType: typeCode,
            componentSubType: subtypeCode,  // Fixed: was componentSubtype, now componentSubType
            componentManufacturer: manufacturerCode,
            componentFlags: 0,
            componentFlagsMask: 0
        )
        
        guard let component = AudioComponentFindNext(nil, &description) else {
            throw RuntimeError("Audio Unit not found")
        }
        
        var au: AudioUnit?
        let instantiateStatus = AudioComponentInstanceNew(component, &au)
        guard instantiateStatus == noErr, let audioUnit = au else {
            throw RuntimeError("Failed to instantiate Audio Unit: \(instantiateStatus)")
        }
        
        defer {
            AudioComponentInstanceDispose(audioUnit)
        }
        
        let initStatus = AudioUnitInitialize(audioUnit)
        guard initStatus == noErr else {
            throw RuntimeError("Failed to initialize Audio Unit: \(initStatus)")
        }
        
        defer {
            AudioUnitUninitialize(audioUnit)
        }
        
        // Get parameter list
        var paramListSize: UInt32 = 0
        // Fixed: Use UnsafeMutableRawPointer(bitPattern: 0) instead of nil
        let paramListStatus = AudioUnitGetProperty(audioUnit, kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, UnsafeMutableRawPointer(bitPattern: 0), &paramListSize)
        guard paramListStatus == noErr else {
            throw RuntimeError("Failed to get parameter list size: \(paramListStatus)")
        }
        
        let paramCount = Int(paramListSize) / MemoryLayout<AudioUnitParameterID>.size
        var parameterIDs = [AudioUnitParameterID](repeating: 0, count: paramCount)
        
        let getParamsStatus = AudioUnitGetProperty(
            audioUnit,
            kAudioUnitProperty_ParameterList,
            kAudioUnitScope_Global,
            0,
            &parameterIDs,
            &paramListSize
        )
        guard getParamsStatus == noErr else {
            throw RuntimeError("Failed to get parameter list: \(getParamsStatus)")
        }
        
        print("üìã Available parameters for \(type)/\(subtype)/\(manufacturer):")
        print("Total parameters: \(paramCount)")
        print("")
        
        for paramID in parameterIDs {
            // Get parameter info
            var paramInfo = AudioUnitParameterInfo()
            var infoSize = UInt32(MemoryLayout<AudioUnitParameterInfo>.size)
            
            let infoStatus = AudioUnitGetProperty(
                audioUnit,
                kAudioUnitProperty_ParameterInfo,
                kAudioUnitScope_Global,
                paramID,
                &paramInfo,
                &infoSize
            )
            
            if infoStatus == noErr {
                let name = withUnsafeBytes(of: paramInfo.name) { bytes in
                    String(cString: bytes.bindMemory(to: CChar.self).baseAddress!)
                }
                
                print("  \(paramID): \(name) [\(paramInfo.minValue)-\(paramInfo.maxValue)]")
            } else {
                print("  \(paramID): (name unavailable)")
            }
        }
    }
}

import Foundation
import AVFoundation
import AudioToolbox
import ArgumentParser

struct RuntimeError: Error, CustomStringConvertible {
    let description: String
    init(_ description: String) {
        self.description = description
    }
}

@main
struct AUPresetGen: ParsableCommand {
    static let configuration = CommandConfiguration(
        abstract: "Generate Audio Unit presets using native macOS APIs",
        subcommands: [DumpParams.self, SavePreset.self, PackageZip.self]
    )
}

struct DumpParams: ParsableCommand {
    static let configuration = CommandConfiguration(abstract: "Dump available parameters for an Audio Unit")
    
    @Option(help: "Component type (4-char string or hex)")
    var type: String
    
    @Option(help: "Component subtype (4-char string or hex)")
    var subtype: String
    
    @Option(help: "Component manufacturer (4-char string or hex)")
    var manufacturer: String
    
    @Flag(help: "Enable verbose output")
    var verbose = false
    
    func run() throws {
        let (componentType, componentSubtype, componentManufacturer) = try parseComponentIdentifiers(type: type, subtype: subtype, manufacturer: manufacturer)
        
        let generator = AUPresetGenerator()
        try generator.dumpParameters(
            type: componentType,
            subtype: componentSubtype,
            manufacturer: componentManufacturer,
            verbose: verbose
        )
    }
}

struct SavePreset: ParsableCommand {
    static let configuration = CommandConfiguration(abstract: "Save Audio Unit preset with parameters")
    
    @Option(help: "Component type (4-char string or hex)")
    var type: String
    
    @Option(help: "Component subtype (4-char string or hex)")
    var subtype: String
    
    @Option(help: "Component manufacturer (4-char string or hex)")
    var manufacturer: String
    
    @Option(help: "JSON file with parameter values")
    var values: String
    
    @Option(help: "Name for the preset")
    var presetName: String
    
    @Option(help: "Output directory")
    var outDir: String
    
    @Option(help: "Plugin name for folder structure (required for --make-zip)")
    var pluginName: String?
    
    @Flag(help: "Create zip package")
    var makeZip = false
    
    @Option(help: "Path for zip file (default: <out-dir>/<plugin-name>.zip)")
    var zipPath: String?
    
    @Option(help: "Bundle root folder name")
    var bundleRoot: String = "Audio Music Apps"
    
    @Flag(help: "Append to existing zip")
    var appendZip = false
    
    @Flag(help: "Force overwrite existing zip")
    var force = false
    
    @Flag(help: "Enable verbose output")
    var verbose = false
    
    func run() throws {
        let (componentType, componentSubtype, componentManufacturer) = try parseComponentIdentifiers(type: type, subtype: subtype, manufacturer: manufacturer)
        
        // Validate required options for zip creation
        if makeZip && pluginName == nil {
            throw ValidationError("--plugin-name is required when using --make-zip")
        }
        
        let generator = AUPresetGenerator()
        try generator.savePreset(
            type: componentType,
            subtype: componentSubtype,
            manufacturer: componentManufacturer,
            valuesFile: values,
            presetName: presetName,
            outDir: outDir,
            pluginName: pluginName,
            makeZip: makeZip,
            zipPath: zipPath,
            bundleRoot: bundleRoot,
            appendZip: appendZip,
            force: force,
            verbose: verbose
        )
    }
}

struct PackageZip: ParsableCommand {
    static let configuration = CommandConfiguration(abstract: "Package existing presets into Logic Pro compatible zip")
    
    @Option(help: "Directory containing existing presets")
    var rootDir: String
    
    @Option(help: "Plugin name for folder structure")
    var pluginName: String
    
    @Option(help: "Output zip path")
    var zipPath: String
    
    @Option(help: "Bundle root folder name")
        var bundleRoot: String = "Audio Music Apps"
    
    @Flag(help: "Force overwrite existing zip")
    var force = false
    
    @Flag(help: "Enable verbose output")
    var verbose = false
    
    func run() throws {
        let generator = AUPresetGenerator()
        try generator.packageExistingPresets(
            rootDir: rootDir,
            pluginName: pluginName,
            zipPath: zipPath,
            bundleRoot: bundleRoot,
            force: force,
            verbose: verbose
        )
    }
}

// Helper function to parse component identifiers
func parseComponentIdentifiers(type: String, subtype: String, manufacturer: String) throws -> (OSType, OSType, OSType) {
    func parseIdentifier(_ identifier: String) throws -> OSType {
        if identifier.hasPrefix("0x") || identifier.hasPrefix("0X") {
            // Parse as hex
            let hexString = String(identifier.dropFirst(2))
            guard let value = UInt32(hexString, radix: 16) else {
                throw ValidationError("Invalid hex identifier: \(identifier)")
            }
            return OSType(value)
        } else if identifier.count == 4 {
            // Parse as 4-character string
            return identifier.withCString { cString in
                return OSType(cString[0]) << 24 | OSType(cString[1]) << 16 | OSType(cString[2]) << 8 | OSType(cString[3])
            }
        } else {
            throw ValidationError("Identifier must be 4 characters or hex (0x...): \(identifier)")
        }
    }
    
    return (
        try parseIdentifier(type),
        try parseIdentifier(subtype),
        try parseIdentifier(manufacturer)
    )
}

class AUPresetGenerator {
    func dumpParameters(type: OSType, subtype: OSType, manufacturer: OSType, verbose: Bool) throws {
        print("üîç Looking for Audio Unit...")
        
        let description = AudioComponentDescription(
            componentType: type,
            componentSubtype: subtype,
            componentManufacturer: manufacturer,
            componentFlags: 0,
            componentFlagsMask: 0
        )
        
        guard let component = AudioComponentFindNext(nil, &description) else {
            throw RuntimeError("Audio Unit not found")
        }
        
        if verbose {
            print("‚úì Found Audio Unit component")
        }
        
        // Get component info
        var componentName: Unmanaged<CFString>?
        AudioComponentCopyName(component, &componentName)
        let name = componentName?.takeRetainedValue() as String? ?? "Unknown"
        
        print("‚úì Plugin: \(name)")
        
        // Instantiate the Audio Unit
        var audioUnit: AudioUnit?
        let status = AudioComponentInstanceNew(component, &audioUnit)
        guard status == noErr, let au = audioUnit else {
            throw RuntimeError("Failed to instantiate Audio Unit: \(status)")
        }
        
        defer {
            AudioComponentInstanceDispose(au)
        }
        
        if verbose {
            print("‚úì Audio Unit instantiated")
        }
        
        // Initialize the Audio Unit
        let initStatus = AudioUnitInitialize(au)
        guard initStatus == noErr else {
            throw RuntimeError("Failed to initialize Audio Unit: \(initStatus)")
        }
        
        defer {
            AudioUnitUninitialize(au)
        }
        
        // Get parameter list
        var paramListSize: UInt32 = 0
        let paramListStatus = AudioUnitGetProperty(au, kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, nil, &paramListSize)
        guard paramListStatus == noErr else {
            throw RuntimeError("Failed to get parameter list size: \(paramListStatus)")
        }
        
        let paramCount = Int(paramListSize) / MemoryLayout<AudioUnitParameterID>.size
        if paramCount == 0 {
            print("No parameters found")
            return
        }
        
        var parameterIDs = [AudioUnitParameterID](repeating: 0, count: paramCount)
        let getParamsStatus = AudioUnitGetProperty(au, kAudioUnitProperty_ParameterList, kAudioUnitScope_Global, 0, &parameterIDs, &paramListSize)
        guard getParamsStatus == noErr else {
            throw RuntimeError("Failed to get parameter list: \(getParamsStatus)")
        }
        
        print("üìä Found \(paramCount) parameters:")
        
        for paramID in parameterIDs {
            // Get parameter info
            var paramInfo = AudioUnitParameterInfo()
            var infoSize = UInt32(MemoryLayout<AudioUnitParameterInfo>.size)
            
            let infoStatus = AudioUnitGetProperty(au, kAudioUnitProperty_ParameterInfo, kAudioUnitScope_Global, paramID, &paramInfo, &infoSize)
            if infoStatus == noErr {
                let name = withUnsafePointer(to: &paramInfo.name) { ptr in
                    return String(cString: UnsafeRawPointer(ptr).assumingMemoryBound(to: CChar.self))
                }
                
                // Get current value
                var currentValue: Float = 0
                let valueStatus = AudioUnitGetParameter(au, paramID, kAudioUnitScope_Global, 0, &currentValue)
                let valueStr = valueStatus == noErr ? String(format: "%.3f", currentValue) : "N/A"
                
                print("  \(paramID): \(name) = \(valueStr) (min: \(paramInfo.minValue), max: \(paramInfo.maxValue))")
            } else {
                print("  \(paramID): <unknown>")
            }
        }
    }
    
    func savePreset(type: OSType, subtype: OSType, manufacturer: OSType, valuesFile: String, presetName: String, outDir: String, pluginName: String?, makeZip: Bool, zipPath: String?, bundleRoot: String, appendZip: Bool, force: Bool, verbose: Bool) throws {
        
        if verbose {
            print("üîç Loading parameter values from \(valuesFile)")
        }
        
        // Load parameter values
        guard let data = FileManager.default.contents(atPath: valuesFile) else {
            throw RuntimeError("Cannot read values file: \(valuesFile)")
        }
        
        let paramValues = try JSONSerialization.jsonObject(with: data) as? [String: Double] ?? [:]
        
        if verbose {
            print("‚úì Loaded \(paramValues.count) parameter values")
        }
        
        // Create output directory
        try FileManager.default.createDirectory(atPath: outDir, withIntermediateDirectories: true, attributes: nil)
        
        // Generate the preset
        let presetURL = URL(fileURLWithPath: outDir).appendingPathComponent("\(presetName).aupreset")
        try generateAUPreset(
            type: type,
            subtype: subtype,
            manufacturer: manufacturer,
            paramValues: paramValues,
            outputURL: presetURL,
            verbose: verbose
        )
        
        print("‚úì Generated preset: \(presetURL.path)")
        
        // Handle zip creation if requested
        if makeZip {
            guard let pluginName = pluginName else {
                throw RuntimeError("Plugin name is required for zip creation")
            }
            
            let finalZipPath = zipPath ?? URL(fileURLWithPath: outDir).appendingPathComponent("\(pluginName).zip").path
            let zipURL = URL(fileURLWithPath: finalZipPath)
            
            // Check if zip exists and handle accordingly
            if FileManager.default.fileExists(atPath: zipURL.path) {
                if appendZip {
                    try appendToExistingZip(presetURL: presetURL, pluginName: pluginName, zipURL: zipURL, bundleRoot: bundleRoot, verbose: verbose)
                } else if force {
                    try FileManager.default.removeItem(at: zipURL)
                    try createNewZip(presetURL: presetURL, pluginName: pluginName, zipURL: zipURL, bundleRoot: bundleRoot, verbose: verbose)
                } else {
                    throw RuntimeError("Zip file exists: \(zipURL.path). Use --force to overwrite or --append-zip to add to existing zip.")
                }
            } else {
                try createNewZip(presetURL: presetURL, pluginName: pluginName, zipURL: zipURL, bundleRoot: bundleRoot, verbose: verbose)
            }
            
            print("‚úì Created zip: \(zipURL.path)")
        }
    }
    
    private func generateAUPreset(type: OSType, subtype: OSType, manufacturer: OSType, paramValues: [String: Double], outputURL: URL, verbose: Bool) throws {
        
        if verbose {
            print("üîç Looking for Audio Unit...")
        }
        
        let description = AudioComponentDescription(
            componentType: type,
            componentSubtype: subtype,
            componentManufacturer: manufacturer,
            componentFlags: 0,
            componentFlagsMask: 0
        )
        
        guard let component = AudioComponentFindNext(nil, &description) else {
            throw RuntimeError("Audio Unit not found")
        }
        
        // Get component info
        var componentName: Unmanaged<CFString>?
        AudioComponentCopyName(component, &componentName)
        let name = componentName?.takeRetainedValue() as String? ?? "Unknown"
        
        if verbose {
            print("‚úì Plugin: \(name)")
        }
        
        // Instantiate the Audio Unit
        var audioUnit: AudioUnit?
        let status = AudioComponentInstanceNew(component, &audioUnit)
        guard status == noErr, let au = audioUnit else {
            throw RuntimeError("Failed to instantiate Audio Unit: \(status)")
        }
        
        defer {
            AudioComponentInstanceDispose(au)
        }
        
        if verbose {
            print("‚úì Audio Unit instantiated")
        }
        
        // Initialize the Audio Unit
        let initStatus = AudioUnitInitialize(au)
        guard initStatus == noErr else {
            throw RuntimeError("Failed to initialize Audio Unit: \(initStatus)")
        }
        
        defer {
            AudioUnitUninitialize(au)
        }
        
        // Apply parameters
        var appliedCount = 0
        if verbose {
            print("üéõÔ∏è Applying \(paramValues.count) parameters...")
        }
        
        for (key, value) in paramValues {
            if let paramID = AudioUnitParameterID(key) {
                let setStatus = AudioUnitSetParameter(au, paramID, kAudioUnitScope_Global, 0, Float(value), 0)
                if setStatus == noErr {
                    appliedCount += 1
                    if verbose {
                        print("  \(paramID) = \(value)")
                    }
                } else if verbose {
                    print("  ‚ö†Ô∏è Failed to set parameter \(paramID): \(setStatus)")
                }
            } else if verbose {
                print("  ‚ö†Ô∏è Invalid parameter ID: \(key)")
            }
        }
        
        if verbose {
            print("‚úì Applied \(appliedCount) parameters")
        }
        
        // Export Audio Unit state
        var propertySize: UInt32 = 0
        let sizeStatus = AudioUnitGetProperty(au, kAudioUnitProperty_ClassInfo, kAudioUnitScope_Global, 0, nil, &propertySize)
        guard sizeStatus == noErr else {
            throw RuntimeError("Failed to get ClassInfo size: \(sizeStatus)")
        }
        
        let classInfoData = UnsafeMutablePointer<UInt8>.allocate(capacity: Int(propertySize))
        defer { classInfoData.deallocate() }
        
        let getStatus = AudioUnitGetProperty(au, kAudioUnitProperty_ClassInfo, kAudioUnitScope_Global, 0, classInfoData, &propertySize)
        guard getStatus == noErr else {
            throw RuntimeError("Failed to get ClassInfo: \(getStatus)")
        }
        
        // Create CFData from the raw data
        let cfData = CFDataCreate(nil, classInfoData, Int(propertySize))!
        
        // Create preset dictionary
        let preset: [String: Any] = [
            "data": cfData,
            "manufacturer": Int(manufacturer),
            "name": name,
            "subtype": Int(subtype),
            "type": Int(type),
            "version": 0
        ]
        
        // Write to .aupreset file
        let plistData = try PropertyListSerialization.data(fromPropertyList: preset, format: .xml, options: 0)
        try plistData.write(to: outputURL)
        
        if verbose {
            print("‚úì Exported Audio Unit state")
        }
    }
    
    private func createNewZip(presetURL: URL, pluginName: String, zipURL: URL, bundleRoot: String, verbose: Bool) throws {
        // Create temporary directory for staging
        let tempDir = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("aupreset_bundle_\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        // Stage the preset file
        let bundleRootURL = try stagePresetForZip(tempRoot: tempDir, pluginName: pluginName, presetFile: presetURL, bundleRootName: bundleRoot)
        
        // Create zip using ditto
        try runDittoZip(at: bundleRootURL, to: zipURL, verbose: verbose)
    }
    
    private func appendToExistingZip(presetURL: URL, pluginName: String, zipURL: URL, bundleRoot: String, verbose: Bool) throws {
        // Create temporary directory for extraction and staging
        let tempDir = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("aupreset_append_\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        // Extract existing zip
        let extractDir = tempDir.appendingPathComponent("extracted")
        try runDittoExtract(from: zipURL, to: extractDir, verbose: verbose)
        
        // Find the bundle root in extracted content
        let extractedBundleRoot = extractDir.appendingPathComponent(bundleRoot)
        
        // Stage new preset file
        _ = try stagePresetForZip(tempRoot: extractDir, pluginName: pluginName, presetFile: presetURL, bundleRootName: bundleRoot)
        
        // Remove old zip and create new one
        try FileManager.default.removeItem(at: zipURL)
        try runDittoZip(at: extractedBundleRoot, to: zipURL, verbose: verbose)
    }
    
    private func stagePresetForZip(tempRoot: URL, pluginName: String, presetFile: URL, bundleRootName: String) throws -> URL {
        let bundleRoot = tempRoot.appendingPathComponent(bundleRootName, isDirectory: true)
        let destDir = bundleRoot
            .appendingPathComponent("Plug-In Settings", isDirectory: true)
            .appendingPathComponent(pluginName, isDirectory: true)
        
        try FileManager.default.createDirectory(at: destDir, withIntermediateDirectories: true)
        
        let destFile = destDir.appendingPathComponent(presetFile.lastPathComponent)
        if FileManager.default.fileExists(atPath: destFile.path) {
            try FileManager.default.removeItem(at: destFile)
        }
        
        try FileManager.default.copyItem(at: presetFile, to: destFile)
        return bundleRoot
    }
    
    private func runDittoZip(at bundleRoot: URL, to zipURL: URL, verbose: Bool) throws {
        let task = Process()
        task.executableURL = URL(fileURLWithPath: "/usr/bin/ditto")
        task.arguments = ["-c", "-k", "--sequesterRsrc", "--keepParent",
                          bundleRoot.lastPathComponent, zipURL.path]
        task.currentDirectoryURL = bundleRoot.deletingLastPathComponent()
        
        let pipe = Pipe()
        task.standardError = pipe
        task.standardOutput = Pipe()
        
        if verbose {
            print("üóúÔ∏è Creating zip with ditto...")
        }
        
        try task.run()
        task.waitUntilExit()
        
        if task.terminationStatus != 0 {
            let err = String(data: pipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
            throw RuntimeError("ditto failed (\(task.terminationStatus)): \(err)")
        }
    }
    
    private func runDittoExtract(from zipURL: URL, to extractURL: URL, verbose: Bool) throws {
        let task = Process()
        task.executableURL = URL(fileURLWithPath: "/usr/bin/ditto")
        task.arguments = ["-x", "-k", zipURL.path, extractURL.path]
        
        let pipe = Pipe()
        task.standardError = pipe
        task.standardOutput = Pipe()
        
        if verbose {
            print("üì¶ Extracting zip with ditto...")
        }
        
        try task.run()
        task.waitUntilExit()
        
        if task.terminationStatus != 0 {
            let err = String(data: pipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8) ?? ""
            throw RuntimeError("ditto extract failed (\(task.terminationStatus)): \(err)")
        }
    }
    
    func packageExistingPresets(rootDir: String, pluginName: String, zipPath: String, bundleRoot: String, force: Bool, verbose: Bool) throws {
        let rootURL = URL(fileURLWithPath: rootDir)
        let zipURL = URL(fileURLWithPath: zipPath)
        
        // Check if zip exists
        if FileManager.default.fileExists(atPath: zipURL.path) && !force {
            throw RuntimeError("Zip file exists: \(zipURL.path). Use --force to overwrite.")
        }
        
        // Find all .aupreset files
        let fileManager = FileManager.default
        let enumerator = fileManager.enumerator(at: rootURL, includingPropertiesForKeys: [.isRegularFileKey])
        var presetFiles: [URL] = []
        
        while let fileURL = enumerator?.nextObject() as? URL {
            if fileURL.pathExtension == "aupreset" {
                presetFiles.append(fileURL)
            }
        }
        
        if presetFiles.isEmpty {
            throw RuntimeError("No .aupreset files found in \(rootDir)")
        }
        
        if verbose {
            print("üìÅ Found \(presetFiles.count) preset files")
        }
        
        // Create temporary directory for staging
        let tempDir = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent("aupreset_package_\(UUID().uuidString)")
        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)
        
        defer {
            try? FileManager.default.removeItem(at: tempDir)
        }
        
        // Stage all preset files
        let bundleRootURL = tempDir.appendingPathComponent(bundleRoot)
        let destDir = bundleRootURL
            .appendingPathComponent("Plug-In Settings", isDirectory: true)
            .appendingPathComponent(pluginName, isDirectory: true)
        
        try FileManager.default.createDirectory(at: destDir, withIntermediateDirectories: true)
        
        for presetFile in presetFiles {
            let destFile = destDir.appendingPathComponent(presetFile.lastPathComponent)
            try FileManager.default.copyItem(at: presetFile, to: destFile)
        }
        
        // Remove existing zip if force is enabled
        if FileManager.default.fileExists(atPath: zipURL.path) {
            try FileManager.default.removeItem(at: zipURL)
        }
        
        // Create zip
        try runDittoZip(at: bundleRootURL, to: zipURL, verbose: verbose)
        
        print("‚úì Created zip: \(zipURL.path) with \(presetFiles.count) presets")
    }
}
